envelope <-
function(
    pattern,
    ppm=FALSE,
    dmz="get",   # retrieve dm from R=m/dm
    frac=1/4,
    env="Gaussian",
    resolution=5E5,
    plotit=FALSE
){

    ############################################################################
    # (1) issue warnings #######################################################
    if((length(resolution)!=length(pattern)) & length(resolution)>1){stop("length of resolution does not match length of pattern list!\n")}
    if(ppm==TRUE & dmz=="get"){stop("\n WARNING: ppm=TRUE -> dmz must be numerical!\n");}
    if(ppm==TRUE & dmz<0){stop("\n WARNING: ppm=TRUE -> dmz must be >0\n");}
    if(dmz=="get"){if(any(resolution<1)){stop("WARNING: invalid resolution!\n")}}
    if(env!="Gaussian" & env!="CauchyLorentz"){stop("WARNING: invalid env argument\n")}
    if(ppm!=FALSE & dmz=="get" & frac>1){stop("WARNING: invalid frac argument\n")}
    if(ppm!=FALSE & dmz=="get" & frac<0){stop("WARNING: invalid frac argument\n")}    
    if(is.list(pattern)==FALSE){stop("WARNING: pattern must be a list\n")}
    if(length(pattern[[1]])<3 || names(pattern[[1]])[1:2]!=c("m/z","abundance")){stop("WARNING: is list, but has invalid entries\n")}
    if(ppm!="TRUE"&ppm!="FALSE"){stop("WARNING: ppm invalid\n")}
    if(plotit!="TRUE"&plotit!="FALSE"){stop("WARNING: plotit invalid. TRUE, FALSE.\n")}
    options(digits=10);
    ############################################################################
    # (2) create stick masses ##################################################
    cat("\n Calculate profiles ...");
    if(env=="Gaussian"){
      type1=0
    }else{
      type1=1
    }
    if(length(resolution)!=length(pattern)){
      resolution<-rep(resolution,length(pattern))
    }
    profiles<-list(0)
    extend<-c(0.5);
    for(i in 1:length(pattern)){
        m<-pattern[[i]][[1]]   
        a<-pattern[[i]][[2]]
        if(ppm==TRUE){
            traceit<-.Call("iso_ppm_Call",
                as.double((min(m)-extend)),
                as.double((max(m)+extend)),
                as.double(dmz)
            )
        }else{
          if(dmz!="get"){
            traceit<-seq(min(m)-extend,max(m)+extend,dmz);
          }else{
            dmz2<-c(mean(m)/resolution[i]);
            traceit<-seq(min(m)-1,max(m)+extend,dmz2*frac);
          }          
        }
        # m:     double array of the isotope pattern mass
        # a:     double array of the isotope pattern abundance
        # trace:   double array profile masses
        # resolution: FWHM with R=m/dm
        # type:   Gaussian=0 // Cauchy-Lorentz=1 
        # threshold: threshold value to skip redundant calculation over all mass peaks
        #              if = 0 -> dynamic
      out <- .Call("iso_profile_with_trace_Call", 
      type1 = as.integer(type1),
      f1 = as.double(m),
      a1 = as.double(a),
      tr1 = as.double(traceit),
      r1 = as.integer(resolution[i]),
      t1 = as.double(0)
    )
       if(length(out[[1]])==0){
           profiles[[i]]<-"error"
           names(profiles)[i]<-names(pattern)[i]
        }else{
          out2<-data.frame(out[[1]],out[[2]])
          names(out2)<-c("m/z","abundance")
          profiles[[i]]<-out2
          names(profiles)[i]<-names(pattern)[i]
      if(plotit==TRUE){
        plot(out2[,1],out2[,2],type="h",xlab="m/z",ylab="Relative abundance",main=names(pattern)[i])
      }
    }
    }
    cat(" done.");
    ############################################################################
    # (3) output ###############################################################
    return(profiles) 
    ############################################################################
    
}
